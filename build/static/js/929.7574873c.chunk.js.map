{"version":3,"file":"static/js/929.7574873c.chunk.js","mappings":"4HAGO,MAAMA,EAAiBC,GAC5B,IAAIC,KAAKC,aAAa,QAAS,CAAEC,SAAU,YAAaC,OAAOJ,GA4EjE,MAAQK,IAAAA,GAAcC,C,uGC1EtB,MAAMC,EAAiBC,EAAAA,GAA0CC,OAC9DC,GAAqB,8EAAfA,EAAEC,UAgFX,EA7EqDC,IACnD,MAAM,MAAEC,EAAK,OAAEC,GAAWF,EAEpBG,GAAeC,EAAAA,EAAAA,UAuErB,OArEAC,EAAAA,EAAAA,WAAU,KACR,MAAMC,EAASC,MAAMC,KACnBd,EAAAA,IAASC,EAAiBG,GAAMA,EAAEW,cACjCX,IAAC,CACAY,eAAgBZ,EAAE,GAAG,GAAGY,eACxBD,aAAcX,EAAE,GAAG,GAAGW,aACtBE,WAAYb,EAAE,MAGfc,KAAK,CAACC,EAAGC,KACR,MAAMC,EAAOF,EAAEF,WAAWd,OAAQmB,GAAMA,EAAEC,KAAO,GAC3CC,EAAOJ,EAAEH,WAAWd,OAAQmB,GAAMA,EAAEC,KAAO,GACjD,OACEC,EAAKC,OAASJ,EAAKI,QACnBJ,EAAKK,OAAO,CAACC,EAAKC,IAAUD,GAAOA,EAAMC,EAAKL,MAAO,GACnDC,EAAKE,OAAO,CAACC,EAAKC,IAAUD,GAAOA,EAAMC,EAAKL,MAAO,KAG1DM,IAAKC,IAAC,CACLf,aAAce,EAAEf,aAChBC,eAAgBc,EAAEd,kBAGhBe,EAAOC,EAAAA,GAAU,CACrBC,SACE,6ZACF1B,MAAOA,EACPC,OAAQA,EACR0B,WAAY,IACZC,EAAG,CACDC,KAAM,QACNC,WAAajC,GACXQ,EAAO0B,KAAMR,GAAMA,EAAEf,eAAiBX,GAAGY,eAC3CuB,MAAO,KACP3B,OAAQA,EAAOiB,IAAKC,GAAMA,EAAEf,eAE9ByB,EAAG,CAAEC,MAAO,CAAC,EAAG,KAChBC,MAAM,EACNC,UAAW,GACXC,MAAO,CACLZ,EAAAA,GAAW,CACTa,OAAQ,MACRN,MAAO,KACPO,UAAW,IAEbd,EAAAA,GAAS/B,EAAgB,CACvB8C,EAAG,WACHZ,EAAG,eACHK,EAAIpC,GAAM4C,KAAKC,IAAI7C,EAAEmB,MACrB2B,KAAO9C,GAAOA,EAAEmB,KAAO,EAAI,OAAS,UACpC4B,OAAS/C,GAAOA,EAAEmB,KAAO,EAAI,OAAS,OACtC6B,YAAa,IAEfpB,EAAAA,GAAU/B,EAAgB,CACxB8C,EAAG,WACHZ,EAAG,eACHkB,KAAOjD,IAAMX,EAAAA,EAAAA,GAAcW,EAAEmB,MAAM+B,eAAe,SAClDC,WAAY,MACZC,IAAK,GACLL,OAAQ,QACRD,KAAM,aAMZ,OADAzC,EAAagD,QAAQC,OAAO3B,GACrB,IAAMA,EAAK4B,UACjB,KAEIC,EAAAA,EAAAA,KAAA,OAAKC,IAAKpD,I","sources":["utils.js","components/consumptionByYearsByCategoriesNegativeTotal.js"],"sourcesContent":["import * as d3 from \"d3\";\n\n// Format with compact notation (e.g., 123M)\nexport const compactNumber = (n) =>\n  new Intl.NumberFormat(\"ru-RU\", { notation: \"compact\" }).format(n);\n\n// a simple duck test for projections and GeoJSON\nexport function rewind(duck, simple) {\n  return duck?.stream\n    ? geoRewindProjection(duck, simple)\n    : duck?.type\n    ? geoRewindFeature(duck, simple)\n    : Array.isArray(duck)\n    ? Array.from(duck, (d) => rewind(d, simple))\n    : duck;\n}\n\nconst geoRewindFeature = (feature, simple) =>\n  geoProjectSimple(feature, geoRewindStream(simple));\n\nconst geoRewindProjection = (projection, simple) => {\n  const { stream: normalize } = geoRewindStream(simple);\n  return { stream: (s) => normalize(projection.stream(s)) };\n};\n\nfunction geoRewindStream(simple = true) {\n  const { geoContains, geoArea } = d3;\n\n  let ring, polygon;\n  return d3.geoTransform({\n    polygonStart() {\n      this.stream.polygonStart();\n      polygon = [];\n    },\n    lineStart() {\n      if (polygon) polygon.push((ring = []));\n      else this.stream.lineStart();\n    },\n    lineEnd() {\n      if (!polygon) this.stream.lineEnd();\n    },\n    point(x, y) {\n      if (polygon) ring.push([x, y]);\n      else this.stream.point(x, y);\n    },\n    polygonEnd() {\n      for (let [i, ring] of polygon.entries()) {\n        ring.push(ring[0].slice());\n        if (\n          i\n            ? // a hole must contain the first point of the polygon\n              !geoContains(\n                { type: \"Polygon\", coordinates: [ring] },\n                polygon[0][0]\n              )\n            : polygon[1]\n            ? // the outer ring must contain the first point of its first hole (if any)\n              !geoContains(\n                { type: \"Polygon\", coordinates: [ring] },\n                polygon[1][0]\n              )\n            : // a single ring polygon must be smaller than a hemisphere (optional)\n              simple &&\n              geoArea({ type: \"Polygon\", coordinates: [ring] }) > 2 * Math.PI\n        ) {\n          ring.reverse();\n        }\n\n        this.stream.lineStart();\n        ring.pop();\n        for (const [x, y] of ring) this.stream.point(x, y);\n        this.stream.lineEnd();\n      }\n      this.stream.polygonEnd();\n      polygon = null;\n    },\n  });\n}\n\n// The function below creates a shallow clone of the object, passing its coordinates through the projection. It is simpler than d3.geoProject, since it doesn’t try to rewind the projected polygons—and thus is suitable to pass the object through a function that maps spherical coordinates to spherical coordinates.\nconst { geoStream } = d3;\n\nfunction geoProjectSimple(object, projection) {\n  const stream = projection.stream;\n  let project;\n  if (!stream) throw new Error(\"invalid projection\");\n  switch (object && object.type) {\n    case \"Feature\":\n      project = projectFeature;\n      break;\n    case \"FeatureCollection\":\n      project = projectFeatureCollection;\n      break;\n    default:\n      project = projectGeometry;\n      break;\n  }\n  return project(object, stream);\n}\n\nfunction projectFeatureCollection(o, stream) {\n  return { ...o, features: o.features.map((f) => projectFeature(f, stream)) };\n}\n\nfunction projectFeature(o, stream) {\n  return { ...o, geometry: projectGeometry(o.geometry, stream) };\n}\n\nfunction projectGeometryCollection(o, stream) {\n  return {\n    ...o,\n    geometries: o.geometries.map((o) => projectGeometry(o, stream)),\n  };\n}\n\nfunction projectGeometry(o, stream) {\n  return !o\n    ? null\n    : o.type === \"GeometryCollection\"\n    ? projectGeometryCollection(o, stream)\n    : o.type === \"Polygon\" || o.type === \"MultiPolygon\"\n    ? projectPolygons(o, stream)\n    : o;\n}\n\nfunction projectPolygons(o, stream) {\n  let coordinates = [];\n  let polygon, line;\n  geoStream(\n    o,\n    stream({\n      polygonStart() {\n        coordinates.push((polygon = []));\n      },\n      polygonEnd() {},\n      lineStart() {\n        polygon.push((line = []));\n      },\n      lineEnd() {\n        line.push(line[0].slice());\n      },\n      point(x, y) {\n        line.push([x, y]);\n      },\n    })\n  );\n  if (o.type === \"Polygon\") coordinates = coordinates[0];\n  return { ...o, coordinates, rewind: true };\n}\n","import { useEffect, useRef } from \"react\";\nimport * as d3 from \"d3\";\nimport * as Plot from \"@observablehq/plot\";\nimport { dataConsumptionNegativeCategoriesSelected } from \"../data/data\";\nimport { compactNumber } from \"../utils\";\n\nconst dataCategories = dataConsumptionNegativeCategoriesSelected.filter(\n  (d) => d.category !== \"Все категории\"\n);\n\nconst ConsumptionByYearsByCategoriesNegativeTotal = (props) => {\n  const { width, height } = props;\n\n  const containerRef = useRef();\n\n  useEffect(() => {\n    const domain = Array.from(\n      d3.group(dataCategories, (d) => d.territory_id),\n      (d) => ({\n        territory_name: d[1][0].territory_name,\n        territory_id: d[1][0].territory_id,\n        categories: d[1],\n      })\n    )\n      .sort((a, b) => {\n        const prev = a.categories.filter((c) => c.diff < 0);\n        const next = b.categories.filter((c) => c.diff < 0);\n        return (\n          next.length - prev.length ||\n          prev.reduce((acc, curr) => (acc += acc + curr.diff), 0) -\n            next.reduce((acc, curr) => (acc += acc + curr.diff), 0)\n        );\n      })\n      .map((t) => ({\n        territory_id: t.territory_id,\n        territory_name: t.territory_name,\n      }));\n\n    const plot = Plot.plot({\n      subtitle:\n        \"Муниципалитеты, в которых расходы год к году сократились в 4 и более категриях\",\n      width: width,\n      height: height,\n      marginLeft: 150,\n      y: {\n        type: \"point\",\n        tickFormat: (d) =>\n          domain.find((t) => t.territory_id === d).territory_name,\n        label: null,\n        domain: domain.map((t) => t.territory_id),\n      },\n      r: { range: [2, 16] },\n      grid: true,\n      insetLeft: 40,\n      marks: [\n        Plot.axisX({\n          anchor: \"top\",\n          label: null,\n          lineWidth: 3,\n        }),\n        Plot.dot(dataCategories, {\n          x: \"category\",\n          y: \"territory_id\",\n          r: (d) => Math.abs(d.diff),\n          fill: (d) => (d.diff > 0 ? \"none\" : \"#ee4444\"),\n          stroke: (d) => (d.diff > 0 ? \"#000\" : \"none\"),\n          strokeWidth: 1,\n        }),\n        Plot.text(dataCategories, {\n          x: \"category\",\n          y: \"territory_id\",\n          text: (d) => compactNumber(d.diff).toLocaleString(\"ru-RU\"),\n          textAnchor: \"end\",\n          dx: -24,\n          stroke: \"white\",\n          fill: \"black\",\n        }),\n      ],\n    });\n\n    containerRef.current.append(plot);\n    return () => plot.remove();\n  }, []);\n\n  return <div ref={containerRef} />;\n};\n\nexport default ConsumptionByYearsByCategoriesNegativeTotal;\n"],"names":["compactNumber","n","Intl","NumberFormat","notation","format","geoStream","d3","dataCategories","dataConsumptionNegativeCategoriesSelected","filter","d","category","props","width","height","containerRef","useRef","useEffect","domain","Array","from","territory_id","territory_name","categories","sort","a","b","prev","c","diff","next","length","reduce","acc","curr","map","t","plot","Plot","subtitle","marginLeft","y","type","tickFormat","find","label","r","range","grid","insetLeft","marks","anchor","lineWidth","x","Math","abs","fill","stroke","strokeWidth","text","toLocaleString","textAnchor","dx","current","append","remove","_jsx","ref"],"sourceRoot":""}