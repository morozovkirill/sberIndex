{"version":3,"file":"static/js/883.5371f920.chunk.js","mappings":"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","sources":["utils.js","components/consumptionByCategories.js"],"sourcesContent":["import * as d3 from \"d3\";\n\n// Format with compact notation (e.g., 123M)\nexport const compactNumber = (n) =>\n  new Intl.NumberFormat(\"ru-RU\", { notation: \"compact\" }).format(n);\n\n// a simple duck test for projections and GeoJSON\nexport function rewind(duck, simple) {\n  return duck?.stream\n    ? geoRewindProjection(duck, simple)\n    : duck?.type\n    ? geoRewindFeature(duck, simple)\n    : Array.isArray(duck)\n    ? Array.from(duck, (d) => rewind(d, simple))\n    : duck;\n}\n\nconst geoRewindFeature = (feature, simple) =>\n  geoProjectSimple(feature, geoRewindStream(simple));\n\nconst geoRewindProjection = (projection, simple) => {\n  const { stream: normalize } = geoRewindStream(simple);\n  return { stream: (s) => normalize(projection.stream(s)) };\n};\n\nfunction geoRewindStream(simple = true) {\n  const { geoContains, geoArea } = d3;\n\n  let ring, polygon;\n  return d3.geoTransform({\n    polygonStart() {\n      this.stream.polygonStart();\n      polygon = [];\n    },\n    lineStart() {\n      if (polygon) polygon.push((ring = []));\n      else this.stream.lineStart();\n    },\n    lineEnd() {\n      if (!polygon) this.stream.lineEnd();\n    },\n    point(x, y) {\n      if (polygon) ring.push([x, y]);\n      else this.stream.point(x, y);\n    },\n    polygonEnd() {\n      for (let [i, ring] of polygon.entries()) {\n        ring.push(ring[0].slice());\n        if (\n          i\n            ? // a hole must contain the first point of the polygon\n              !geoContains(\n                { type: \"Polygon\", coordinates: [ring] },\n                polygon[0][0]\n              )\n            : polygon[1]\n            ? // the outer ring must contain the first point of its first hole (if any)\n              !geoContains(\n                { type: \"Polygon\", coordinates: [ring] },\n                polygon[1][0]\n              )\n            : // a single ring polygon must be smaller than a hemisphere (optional)\n              simple &&\n              geoArea({ type: \"Polygon\", coordinates: [ring] }) > 2 * Math.PI\n        ) {\n          ring.reverse();\n        }\n\n        this.stream.lineStart();\n        ring.pop();\n        for (const [x, y] of ring) this.stream.point(x, y);\n        this.stream.lineEnd();\n      }\n      this.stream.polygonEnd();\n      polygon = null;\n    },\n  });\n}\n\n// The function below creates a shallow clone of the object, passing its coordinates through the projection. It is simpler than d3.geoProject, since it doesn’t try to rewind the projected polygons—and thus is suitable to pass the object through a function that maps spherical coordinates to spherical coordinates.\nconst { geoStream } = d3;\n\nfunction geoProjectSimple(object, projection) {\n  const stream = projection.stream;\n  let project;\n  if (!stream) throw new Error(\"invalid projection\");\n  switch (object && object.type) {\n    case \"Feature\":\n      project = projectFeature;\n      break;\n    case \"FeatureCollection\":\n      project = projectFeatureCollection;\n      break;\n    default:\n      project = projectGeometry;\n      break;\n  }\n  return project(object, stream);\n}\n\nfunction projectFeatureCollection(o, stream) {\n  return { ...o, features: o.features.map((f) => projectFeature(f, stream)) };\n}\n\nfunction projectFeature(o, stream) {\n  return { ...o, geometry: projectGeometry(o.geometry, stream) };\n}\n\nfunction projectGeometryCollection(o, stream) {\n  return {\n    ...o,\n    geometries: o.geometries.map((o) => projectGeometry(o, stream)),\n  };\n}\n\nfunction projectGeometry(o, stream) {\n  return !o\n    ? null\n    : o.type === \"GeometryCollection\"\n    ? projectGeometryCollection(o, stream)\n    : o.type === \"Polygon\" || o.type === \"MultiPolygon\"\n    ? projectPolygons(o, stream)\n    : o;\n}\n\nfunction projectPolygons(o, stream) {\n  let coordinates = [];\n  let polygon, line;\n  geoStream(\n    o,\n    stream({\n      polygonStart() {\n        coordinates.push((polygon = []));\n      },\n      polygonEnd() {},\n      lineStart() {\n        polygon.push((line = []));\n      },\n      lineEnd() {\n        line.push(line[0].slice());\n      },\n      point(x, y) {\n        line.push([x, y]);\n      },\n    })\n  );\n  if (o.type === \"Polygon\") coordinates = coordinates[0];\n  return { ...o, coordinates, rewind: true };\n}\n","import { useEffect, useRef } from \"react\";\nimport * as Plot from \"@observablehq/plot\";\nimport { dataConsumptionByYearsByCategories } from \"../data/data\";\nimport { compactNumber } from \"../utils\";\n\nfunction sLine(context, gapX = 10, gapY = 10, reversed = false) {\n  return new SLine(context, gapX, gapY, reversed);\n}\n\nfunction SLine(context, gapX, gapY, reversed) {\n  this._context = context;\n  this._gapX = gapX;\n  this._gapY = gapY;\n  this._reversed = reversed;\n}\n\nSLine.prototype = {\n  areaStart: function () {\n    this._line = 0;\n  },\n  areaEnd: function () {\n    this._line = NaN;\n  },\n  lineStart: function () {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function () {\n    if (this._line || (this._line !== 0 && this._point === 1))\n      this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function (x, y) {\n    x = +x;\n    y = +y;\n    switch (this._point) {\n      case 0:\n        this._point = 1;\n        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n        break;\n      case 1:\n        this._point = 2; // falls thgough\n      default: {\n        if (this._reversed) {\n          this._context.lineTo(this._x, this._y - this._gapY);\n          this._context.lineTo(x, y - this._gapY);\n          this._context.lineTo(x, y);\n        } else {\n          this._context.lineTo(this._x, this._y + this._gapY);\n          this._context.lineTo(x, y + this._gapY);\n          this._context.lineTo(x, y);\n        }\n        break;\n      }\n    }\n    this._x = x;\n    this._y = y;\n  },\n};\n\nconst ConsumptionByCategories = (props) => {\n  const { width, height } = props;\n\n  const containerRef = useRef();\n\n  const categories = [\n    \"Общественное питание\",\n    \"Продовольствие\",\n    \"Транспорт\",\n    \"Маркетплейсы\",\n    \"Здоровье\",\n    \"Другие категории\",\n  ];\n\n  const summary = categories\n    .map((elem) => {\n      const positive = dataConsumptionByYearsByCategories.filter(\n        (item) => item.category === elem && item.diff > 0\n      );\n      const summaryPositive = positive.reduce(\n        (acc, curr) => acc + curr.diff,\n        0\n      );\n      const minPositive = positive.length\n        ? Math.min(...positive.map((elem) => elem.diff))\n        : null;\n      const maxPositive = positive.length\n        ? Math.max(...positive.map((elem) => elem.diff))\n        : null;\n\n      const negative = dataConsumptionByYearsByCategories.filter(\n        (item) => item.category === elem && item.diff <= 0\n      );\n      const summaryNegative = negative.reduce(\n        (acc, curr) => acc + curr.diff,\n        0\n      );\n      const minNegative = negative.length\n        ? Math.min(...negative.map((elem) => elem.diff))\n        : null;\n      const maxNegative = negative.length\n        ? Math.max(...negative.map((elem) => elem.diff))\n        : null;\n\n      return [\n        {\n          category: elem,\n          type: \"positive\",\n          value: summaryPositive,\n          min: minPositive,\n          max: maxPositive,\n          count: positive.length,\n        },\n        {\n          category: elem,\n          type: \"negative\",\n          value: summaryNegative,\n          min: minNegative,\n          max: maxNegative,\n          count: negative.length,\n        },\n      ];\n    })\n    .flat();\n\n  useEffect(() => {\n    const plot = Plot.plot({\n      title: \"Как менялись расходы в 2023 / 24 годах по мунициалитетам\",\n      subtitle:\n        \"На графике разница всех средних безналичных расходов по месяцам в течение года\",\n      caption:\n        \"Точка на графике – муниципальное образование. Распределение по горизонтали строится на основе разницы сумм средних месячных расходов за год (сумма средних месячных расходов за 2024 минус сумма за 2023). Распределение по вертикали основано на количестве МО с одинаковым или схожим значением в разнице расходов.\\n\\nВ выборке участвуют только те МО, по которым есть полные данные (расходы за все месяцы в течение двух лет).\",\n      width: width,\n      height: height,\n      marginLeft: 150,\n      grid: true,\n      y: { label: null, ticks: 0 },\n      fy: {\n        label: \"Категории расходов\",\n        axis: \"left\",\n        domain: categories,\n        padding: 0,\n      },\n      x: {\n        type: \"pow\",\n        exponent: 1 / 3,\n        ticks: 10,\n      },\n      length: { range: [90, 120], domain: [6, 9] },\n      marks: [\n        Plot.ruleY([0], { strokeOpacity: 0.1 }),\n        Plot.axisX({\n          anchor: \"top\",\n          ticks: 10,\n          label: \"Δ 2023 — 2024, тыс. ₽\",\n          labelOffset: -10,\n          tickFormat: (d) => d / 1000,\n        }),\n        Plot.axisX({\n          anchor: \"bottom\",\n          ticks: 10,\n          tickFormat: (d) => d / 1000,\n          label: null,\n        }),\n        Plot.dot(\n          dataConsumptionByYearsByCategories.filter(\n            (elem) => elem.category !== \"Все категории\"\n          ),\n          Plot.dodgeY(\"middle\", {\n            x: \"diff\",\n            fy: \"category\",\n            r: 1,\n            fill: (d) => (d.diff <= 0 ? \"red\" : \"black\"),\n            strokeWidth: 0,\n            channels: {\n              territory_name: {\n                label: \"Муниципалитет:\",\n                value: \"territory_name\",\n              },\n              region_name: { label: \"Регион:\", value: \"region_name\" },\n              diff: {\n                label: \"Разница:\",\n                value: (d) =>\n                  compactNumber(d.diff).toLocaleString() +\n                  \" ₽\" +\n                  \" (\" +\n                  (Math.round(d.diffPercent * 10) / 10).toLocaleString(\n                    \"ru-RU\"\n                  ) +\n                  \"%)\",\n              },\n            },\n            tip: {\n              format: {\n                x: false,\n                fy: false,\n              },\n            },\n          })\n        ),\n\n        // Notes\n        Plot.text(\n          [\"Суммарное сокращение расходов в категории\\nпо муниципалитетам\"],\n          {\n            x: -3000,\n            fy: (d) => \"Общественное питание\",\n            dy: 140,\n            textAnchor: \"center\",\n            fill: \"black\",\n            stroke: \"white\",\n            strokeWidth: 8,\n          }\n        ),\n        Plot.vector([0], {\n          x: -3000,\n          fy: (d) => \"Общественное питание\",\n          dy: 120,\n          length: 60,\n          rotate: -30,\n          strokeWidth: 1,\n          bend: false,\n          wingRatio: 0,\n          r: 0,\n          anchor: \"start\",\n        }),\n        Plot.text(\n          [\n            \"В категории «Маркетплейсы»\\nсокращения расходов нет ни в одном\\nмуниципалитете\",\n          ],\n          {\n            x: -3000,\n            fy: (d) => \"Маркетплейсы\",\n            dy: -80,\n            textAnchor: \"center\",\n            fill: \"black\",\n            stroke: \"white\",\n            strokeWidth: 8,\n          }\n        ),\n        Plot.vector([0], {\n          x: -3000,\n          fy: (d) => \"Маркетплейсы\",\n          dy: -50,\n          length: 60,\n          rotate: 150,\n          strokeWidth: 1,\n          bend: false,\n          wingRatio: 0,\n          r: 0,\n          anchor: \"start\",\n        }),\n\n        // summary lines\n        categories.map((elem, i) => {\n          const c = summary.filter(\n            (item) =>\n              elem === item.category &&\n              item.type === \"negative\" &&\n              (item.min !== null) & (item.max !== null)\n          );\n          const yOffset =\n            elem === \"Общественное питание\"\n              ? 32\n              : elem === \"Продовольствие\"\n              ? 8\n              : elem === \"Здоровье\"\n              ? 24\n              : elem === \"Маркетплейсы\"\n              ? 0\n              : elem === \"Транспорт\"\n              ? 40\n              : 24;\n          return c.length\n            ? [\n                Plot.lineX(\n                  c.map((item) => [{ x: item.min }, { x: item.max }]).flat(),\n                  {\n                    x: \"x\",\n                    y: 0,\n                    dy: yOffset,\n                    fy: (d) => elem,\n                    curve: (context) => sLine(context, 8, 8),\n                    stroke: \"rgba(0, 0, 0, .8)\",\n                    strokeWidth: 1,\n                  }\n                ),\n                Plot.text(\n                  c.map((item) => ({\n                    x: item.min,\n                    value: item.value,\n                    count: item.count,\n                  })),\n                  {\n                    x: \"x\",\n                    fy: (d) => elem,\n                    dy: yOffset + 22,\n                    textAnchor: \"start\",\n                    text: (d) =>\n                      compactNumber(d.value) +\n                      \" ₽, \" +\n                      compactNumber(d.count) +\n                      \" МО\",\n                  }\n                ),\n              ]\n            : null;\n        }),\n\n        categories.map((elem, i) => {\n          const c = summary.filter(\n            (item) =>\n              elem === item.category &&\n              item.type === \"positive\" &&\n              (item.min !== null) & (item.max !== null)\n          );\n          const yOffset =\n            elem === \"Общественное питание\"\n              ? 80\n              : elem === \"Продовольствие\"\n              ? 140\n              : elem === \"Здоровье\"\n              ? 120\n              : elem === \"Маркетплейсы\"\n              ? 170\n              : elem === \"Транспорт\"\n              ? 80\n              : 70;\n          return c.length\n            ? [\n                Plot.lineX(\n                  c.map((item) => [{ x: item.min }, { x: item.max }]).flat(),\n                  {\n                    x: \"x\",\n                    y: 0,\n                    dy: yOffset,\n                    fy: (d) => elem,\n                    curve: (context) => sLine(context, 8, 8),\n                    stroke: \"rgba(0, 0, 0, .8)\",\n                    strokeWidth: 1,\n                  }\n                ),\n                Plot.text(\n                  c.map((item) => ({\n                    x: item.max,\n                    value: item.value,\n                    count: item.count,\n                  })),\n                  {\n                    x: \"x\",\n                    fy: (d) => elem,\n                    dy: yOffset + 22,\n                    textAnchor: \"end\",\n                    text: (d) =>\n                      compactNumber(d.value) +\n                      \" ₽, \" +\n                      compactNumber(d.count) +\n                      \" МО\",\n                  }\n                ),\n              ]\n            : null;\n        }),\n\n        // legend\n        Plot.text([\"Увеличение расходов →\"], {\n          x: 0,\n          fy: (d) => \"Общественное питание\",\n          textAnchor: \"start\",\n          dx: 8,\n          dy: -130,\n        }),\n        Plot.text([\"← Уменьшение расходов\"], {\n          x: 0,\n          fy: (d) => \"Общественное питание\",\n          textAnchor: \"end\",\n          dx: -8,\n          dy: -130,\n        }),\n\n        Plot.text(\n          dataConsumptionByYearsByCategories\n            .filter((elem) => elem.category === \"Общественное питание\")\n            .sort((a, b) => a.diff - b.diff),\n          Plot.selectFirst({\n            x: \"diff\",\n            fy: (d) => \"Общественное питание\",\n            textAnchor: \"center\",\n            dy: -24,\n            text: (d) => d.territory_name + \" МО,\\n\" + d.region_name,\n          })\n        ),\n        Plot.dot(\n          dataConsumptionByYearsByCategories\n            .filter((elem) => elem.category === \"Общественное питание\")\n            .sort((a, b) => a.diff - b.diff),\n          Plot.selectFirst({\n            x: \"diff\",\n            fy: (d) => \"Общественное питание\",\n            r: 4,\n            strokeWidth: 1,\n          })\n        ),\n      ],\n      style: { overflow: \"visible\" },\n    });\n\n    containerRef.current.append(plot);\n    return () => plot.remove();\n  }, []);\n\n  return <div ref={containerRef} />;\n};\n\nexport default ConsumptionByCategories;\n"],"names":["compactNumber","n","Intl","NumberFormat","notation","format","geoStream","d3","sLine","context","SLine","arguments","length","undefined","gapX","gapY","reversed","this","_context","_gapX","_gapY","_reversed","prototype","areaStart","_line","areaEnd","NaN","lineStart","_x","_y","_point","lineEnd","closePath","point","x","y","lineTo","moveTo","props","width","height","containerRef","useRef","categories","summary","map","elem","positive","dataConsumptionByYearsByCategories","filter","item","category","diff","summaryPositive","reduce","acc","curr","minPositive","Math","min","maxPositive","max","negative","summaryNegative","minNegative","maxNegative","type","value","count","flat","useEffect","plot","Plot","title","subtitle","caption","marginLeft","grid","label","ticks","fy","axis","domain","padding","exponent","range","marks","strokeOpacity","anchor","labelOffset","tickFormat","d","r","fill","strokeWidth","channels","territory_name","region_name","toLocaleString","round","diffPercent","tip","dy","textAnchor","stroke","rotate","bend","wingRatio","i","c","yOffset","curve","text","dx","sort","a","b","style","overflow","current","append","remove","_jsx","ref"],"sourceRoot":""}