{"version":3,"file":"static/js/110.5a969594.chunk.js","mappings":"4KAKA,MAoEA,EApE6BA,IAC3B,MAAM,MAAEC,EAAK,OAAEC,GAAWF,EAEpBG,GAAeC,EAAAA,EAAAA,UA8DrB,OA5DAC,EAAAA,EAAAA,WAAU,KACR,MAAMC,EAAOC,EAAAA,GAAU,CACrBC,SACE,kWACFC,QACE,s2BACFR,MAAOA,EACPC,OAAQA,EACRQ,WAAY,IACZC,MAAO,GACPC,EAAG,CACDC,KAAM,MACNC,MAAM,EACNC,WAAaC,IAAOA,EAAI,KAAMC,eAAe,SAC7CC,MAAO,oKACPC,aAAc,GAEhBC,EAAG,CACDP,KAAM,QACNE,WAAaC,GACXK,EAAAA,GAA4BC,KAAMC,GAASA,EAAKC,eAAiBR,GAC9DS,eACLX,MAAM,EACNI,MAAO,MAETQ,MAAO,CACLnB,EAAAA,GACEc,EAAAA,GAA4BM,OACzBJ,GAASA,EAAKK,OAAO,MAAQL,EAAKK,OAAO,OAE5C,CACEC,GAAKb,GAAMA,EAAEY,OAAO,MACpBE,GAAKd,GAAMA,EAAEY,OAAO,MACpBR,EAAG,eACHW,OAAQ,YAGZxB,EAAAA,GACEc,EAAAA,GAA4BM,OACzBJ,GAASA,EAAKK,OAAO,MAAQL,EAAKK,OAAO,OAE5C,CACEhB,EAAII,GAAMA,EAAEY,OAAO,OAASZ,EAAEY,OAAO,MAAQZ,EAAEY,OAAO,OAAS,EAC/DR,EAAG,eACHY,KAAOhB,IACLiB,EAAAA,EAAAA,GAAcjB,EAAEY,OAAO,MAAQZ,EAAEY,OAAO,OAAOX,eAC7C,SAEJiB,WAAY,SACZC,IAAK,GACLC,SAAWpB,KAAQA,EAAEY,OAAO,MAAQZ,EAAEY,OAAO,OAAS,IAAO,OAOrE,OADAzB,EAAakC,QAAQC,OAAOhC,GACrB,IAAMA,EAAKiC,UACjB,KAEIC,EAAAA,EAAAA,KAAA,OAAKC,IAAKtC,I,8CCnEZ,MAAM8B,EAAiBS,GAC5B,IAAIC,KAAKC,aAAa,QAAS,CAAEC,SAAU,YAAaC,OAAOJ,GA4EjE,MAAQK,IAAAA,GAAcC,C","sources":["components/salaryByTerritories.js","utils.js"],"sourcesContent":["import { useEffect, useRef } from \"react\";\nimport * as Plot from \"@observablehq/plot\";\nimport { dataUnitedConsumptionSalary } from \"../data/data\";\nimport { compactNumber } from \"../utils\";\n\nconst SalaryByTerritories = (props) => {\n  const { width, height } = props;\n\n  const containerRef = useRef();\n\n  useEffect(() => {\n    const plot = Plot.plot({\n      subtitle:\n        \"Муниципалитеты, в которых год к году сократились заработные платы\",\n      caption:\n        \"Разница в среднем заработоке за январь–декабрь 2024 и 2023 годов. В выборке участвуют только те муниципалитеты, по которым есть полные данные (все месяцы в течение двух лет).\",\n      width: width,\n      height: height,\n      marginLeft: 150,\n      inset: 40,\n      x: {\n        type: \"log\",\n        grid: true,\n        tickFormat: (d) => (d / 1000).toLocaleString(\"ru-RU\"),\n        label: \"Среднегодовой заработок, тыс. ₽\",\n        labelOffset: -8,\n      },\n      y: {\n        type: \"point\",\n        tickFormat: (d) =>\n          dataUnitedConsumptionSalary.find((elem) => elem.territory_id === d)\n            .territory_name,\n        grid: true,\n        label: null,\n      },\n      marks: [\n        Plot.arrow(\n          dataUnitedConsumptionSalary.filter(\n            (elem) => elem.salary[2024] < elem.salary[2023]\n          ),\n          {\n            x1: (d) => d.salary[2023],\n            x2: (d) => d.salary[2024],\n            y: \"territory_id\",\n            stroke: \"#ee4444\",\n          }\n        ),\n        Plot.text(\n          dataUnitedConsumptionSalary.filter(\n            (elem) => elem.salary[2024] < elem.salary[2023]\n          ),\n          {\n            x: (d) => d.salary[2024] + (d.salary[2023] - d.salary[2024]) / 2,\n            y: \"territory_id\",\n            text: (d) =>\n              compactNumber(d.salary[2024] - d.salary[2023]).toLocaleString(\n                \"ru-RU\"\n              ),\n            textAnchor: \"center\",\n            dy: -12,\n            fontSize: (d) => -(d.salary[2024] - d.salary[2023]) / 1000 + 8,\n          }\n        ),\n      ],\n    });\n\n    containerRef.current.append(plot);\n    return () => plot.remove();\n  }, []);\n\n  return <div ref={containerRef} />;\n};\n\nexport default SalaryByTerritories;\n","import * as d3 from \"d3\";\n\n// Format with compact notation (e.g., 123M)\nexport const compactNumber = (n) =>\n  new Intl.NumberFormat(\"ru-RU\", { notation: \"compact\" }).format(n);\n\n// a simple duck test for projections and GeoJSON\nexport function rewind(duck, simple) {\n  return duck?.stream\n    ? geoRewindProjection(duck, simple)\n    : duck?.type\n    ? geoRewindFeature(duck, simple)\n    : Array.isArray(duck)\n    ? Array.from(duck, (d) => rewind(d, simple))\n    : duck;\n}\n\nconst geoRewindFeature = (feature, simple) =>\n  geoProjectSimple(feature, geoRewindStream(simple));\n\nconst geoRewindProjection = (projection, simple) => {\n  const { stream: normalize } = geoRewindStream(simple);\n  return { stream: (s) => normalize(projection.stream(s)) };\n};\n\nfunction geoRewindStream(simple = true) {\n  const { geoContains, geoArea } = d3;\n\n  let ring, polygon;\n  return d3.geoTransform({\n    polygonStart() {\n      this.stream.polygonStart();\n      polygon = [];\n    },\n    lineStart() {\n      if (polygon) polygon.push((ring = []));\n      else this.stream.lineStart();\n    },\n    lineEnd() {\n      if (!polygon) this.stream.lineEnd();\n    },\n    point(x, y) {\n      if (polygon) ring.push([x, y]);\n      else this.stream.point(x, y);\n    },\n    polygonEnd() {\n      for (let [i, ring] of polygon.entries()) {\n        ring.push(ring[0].slice());\n        if (\n          i\n            ? // a hole must contain the first point of the polygon\n              !geoContains(\n                { type: \"Polygon\", coordinates: [ring] },\n                polygon[0][0]\n              )\n            : polygon[1]\n            ? // the outer ring must contain the first point of its first hole (if any)\n              !geoContains(\n                { type: \"Polygon\", coordinates: [ring] },\n                polygon[1][0]\n              )\n            : // a single ring polygon must be smaller than a hemisphere (optional)\n              simple &&\n              geoArea({ type: \"Polygon\", coordinates: [ring] }) > 2 * Math.PI\n        ) {\n          ring.reverse();\n        }\n\n        this.stream.lineStart();\n        ring.pop();\n        for (const [x, y] of ring) this.stream.point(x, y);\n        this.stream.lineEnd();\n      }\n      this.stream.polygonEnd();\n      polygon = null;\n    },\n  });\n}\n\n// The function below creates a shallow clone of the object, passing its coordinates through the projection. It is simpler than d3.geoProject, since it doesn’t try to rewind the projected polygons—and thus is suitable to pass the object through a function that maps spherical coordinates to spherical coordinates.\nconst { geoStream } = d3;\n\nfunction geoProjectSimple(object, projection) {\n  const stream = projection.stream;\n  let project;\n  if (!stream) throw new Error(\"invalid projection\");\n  switch (object && object.type) {\n    case \"Feature\":\n      project = projectFeature;\n      break;\n    case \"FeatureCollection\":\n      project = projectFeatureCollection;\n      break;\n    default:\n      project = projectGeometry;\n      break;\n  }\n  return project(object, stream);\n}\n\nfunction projectFeatureCollection(o, stream) {\n  return { ...o, features: o.features.map((f) => projectFeature(f, stream)) };\n}\n\nfunction projectFeature(o, stream) {\n  return { ...o, geometry: projectGeometry(o.geometry, stream) };\n}\n\nfunction projectGeometryCollection(o, stream) {\n  return {\n    ...o,\n    geometries: o.geometries.map((o) => projectGeometry(o, stream)),\n  };\n}\n\nfunction projectGeometry(o, stream) {\n  return !o\n    ? null\n    : o.type === \"GeometryCollection\"\n    ? projectGeometryCollection(o, stream)\n    : o.type === \"Polygon\" || o.type === \"MultiPolygon\"\n    ? projectPolygons(o, stream)\n    : o;\n}\n\nfunction projectPolygons(o, stream) {\n  let coordinates = [];\n  let polygon, line;\n  geoStream(\n    o,\n    stream({\n      polygonStart() {\n        coordinates.push((polygon = []));\n      },\n      polygonEnd() {},\n      lineStart() {\n        polygon.push((line = []));\n      },\n      lineEnd() {\n        line.push(line[0].slice());\n      },\n      point(x, y) {\n        line.push([x, y]);\n      },\n    })\n  );\n  if (o.type === \"Polygon\") coordinates = coordinates[0];\n  return { ...o, coordinates, rewind: true };\n}\n"],"names":["props","width","height","containerRef","useRef","useEffect","plot","Plot","subtitle","caption","marginLeft","inset","x","type","grid","tickFormat","d","toLocaleString","label","labelOffset","y","dataUnitedConsumptionSalary","find","elem","territory_id","territory_name","marks","filter","salary","x1","x2","stroke","text","compactNumber","textAnchor","dy","fontSize","current","append","remove","_jsx","ref","n","Intl","NumberFormat","notation","format","geoStream","d3"],"sourceRoot":""}